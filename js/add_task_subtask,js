/**
 * Shows or hides the clear button based on the given value.
 * @param {boolean} value - The value indicating whether to show or hide the clear button.
 */
function showClearButton(value) {
    document.getElementById("clear-subtask").style.display = value
        ? "inline"
        : "none";
}

/**
 * Clears the subtask input field and hides the clear button.
 */
function clearSubtaskInput() {
    document.getElementById("subtask").value = "";
    document.getElementById("clear-subtask").style.display = "none";
}

document
    .querySelectorAll('.custom-checkbox input[type="checkbox"]')
    .forEach((checkbox) => {
        checkbox.addEventListener("change", function () {
            const imgElement = this.nextElementSibling;
            if (this.checked) {
                imgElement.src = "./assets/img/checkboxChecked.png";
            } else {
                imgElement.src = "./assets/img/checkbox.png";
            }
        });
    });

/**
 * Toggles the visibility of the dropdown menu and updates the arrow icon accordingly.
 * @param {Event} event - The event object triggered by the user action.
 */
function toggleDropdown(event) {
    const options = document.querySelector(".dropdown-options");
    const arrow = document.querySelector(".dropdown-arrow");
    const isOpen = options.style.display === "block";
    options.style.display = isOpen ? "none" : "block";
    arrow.src = isOpen
        ? "./assets/img/custom-arrow.png"
        : "./assets/img/custom-arrow-up.png";
    event.stopPropagation();
}

/**
 * Handles the selection of an option in the dropdown menu.
 *
 * @param {Event} event - The event object triggered by the selection.
 */
function selectOption(event) {
    const selectedText = event.target.textContent;
    const selectedValue = event.target.getAttribute("data-value");
    const arrow = document.querySelector(".dropdown-arrow");
    document.querySelector(".dropdown-selected").textContent = selectedText;
    document.querySelector(".dropdown-options").style.display = "none";
    document.getElementById("category").value = selectedValue;
    arrow.src = "./assets/img/custom-arrow.png";
}

/**
 * Sets up event listeners for the dropdown menu.
 */
function setupDropdownListeners() {
    const dropdownSelected = document.querySelector(".dropdown-selected");
    const dropdownArrow = document.querySelector(".dropdown-arrow");
    const dropdownOptions = document.querySelectorAll(".dropdown-option");
    dropdownSelected.addEventListener("click", toggleDropdown);
    dropdownArrow.addEventListener("click", toggleDropdown);
    dropdownOptions.forEach((option) => {
        option.addEventListener("click", selectOption);
    });
    window.addEventListener("click", function () {
        const options = document.querySelector(".dropdown-options");
        const arrow = document.querySelector(".dropdown-arrow");
        if (options.style.display === "block") {
            options.style.display = "none";
            arrow.src = "./assets/img/custom-arrow.png";
        }
    });
}

document.addEventListener("DOMContentLoaded", setupDropdownListeners);

/**
 * Handles the click event outside of the dropdown-selected element.
 * If the clicked element does not match the dropdown-selected class, it hides the dropdown-options element.
 * @param {Event} event - The click event object.
 */
function handleClickOutside(event) {
    if (!event.target.matches(".dropdown-selected")) {
        document.querySelector(".dropdown-options").style.display = "none";
    }
}

/**
 * Handles keyboard accessibility for the event.
 * @param {KeyboardEvent} event - The keyboard event object.
 */
function handleKeyboardAccessibility(event) {
    if (event.key === "Enter") {
        toggleDropdown();
    }
}

/**
 * Initializes the dropdown functionality.
 * Sets up event listeners for the dropdown and handles keyboard accessibility.
 */
function initializeDropdown() {
    setupDropdownListeners();
    window.addEventListener("click", handleClickOutside, true);
    document
        .querySelector(".dropdown-selected")
        .addEventListener("keydown", handleKeyboardAccessibility);
}

document.addEventListener("DOMContentLoaded", initializeDropdown);

/**
 * Closes the dropdown and fills the dropdown list.
 */
function closeDropdown() {
    fillDropdownList();
    document.getElementById("dropDownContacts").style.display = "none";
}

/**
 * Creates a checkbox element for a subtask, setting its checked status based on the subtask's completion status.
 * Updates the subtask's completed property when the checkbox state changes.
 * @param {Object} subtask - The subtask object with a completed property.
 * @param {number} index - The index of the subtask in the subtasks array.
 * @returns {HTMLElement} The created checkbox element.
 */
function createCheckbox(subtask, index) {
    let checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = subtask.completed;
    checkbox.onchange = function () {
        subtasks[index].completed = this.checked;
    };
    return checkbox;
}

/**
 * Creates a disabled text input element pre-filled with the name of a subtask.
 * @param {Object} subtask - The subtask object containing the name to be displayed.
 * @returns {HTMLElement} The created text input element, configured as disabled.
 */
function createTextInput(subtask) {
    let textInput = document.createElement("input");
    textInput.type = "text";
    textInput.value = subtask.name;
    textInput.disabled = true;
    return textInput;
}

/**
 * Creates an edit button for a subtask input field, allowing the field to be toggled between editable and non-editable states.
 * The button toggles its icon based on the state of the input field.
 * @param {HTMLElement} textInput - The text input element associated with the subtask.
 * @param {number} index - The index of the subtask in the subtasks array, used to update the subtask's name upon confirmation.
 * @returns {HTMLElement} The created button element with an attached event listener for toggling edit mode.
 */
function createEditButton(textInput, index) {
    let editButton = document.createElement("button");
    editButton.type = "button";
    editButton.classList.add("subtaskEditBtn");
    let editIcon = document.createElement("img");
    editIcon.src = "assets/img/edit.png";
    editIcon.alt = "Edit";
    editButton.appendChild(editIcon);
    editButton.onclick = function () {
        if (textInput.disabled) {
            textInput.disabled = false;
            textInput.focus();
            editIcon.src = "assets/img/check (2).png";
        } else {
            subtasks[index].name = textInput.value.trim();
            textInput.disabled = true;
            editIcon.src = "assets/img/edit.png";
            updateSubtaskList();
        }
    };
    return editButton;
}

/**
 * Creates a delete button with an icon for removing a subtask. The button, when clicked, removes the subtask at the specified index.
 * @param {number} index - The index of the subtask to be deleted.
 * @returns {HTMLElement} The created delete button with an attached event listener for subtask removal.
 */
function createDeleteButton(index) {
    let deleteButton = document.createElement("button");
    deleteButton.type = "button";
    deleteButton.classList.add("subtaskDeleteBtn");
    let deleteIcon = document.createElement("img");
    deleteIcon.src = "assets/img/delete.png";
    deleteIcon.alt = "Delete";
    deleteButton.appendChild(deleteIcon);
    deleteButton.onclick = function () {
        removeSubtask(index);
    };
    return deleteButton;
}

/**
 * Updates and re-renders the list of subtasks. Each subtask is displayed with a checkbox, a text input, and edit and delete buttons.
 */
function updateSubtaskList() {
    subtaskList.innerHTML = "";
    subtasks.forEach((subtask, index) => {
        let li = document.createElement("li");
        let checkbox = createCheckbox(subtask, index);
        let textInput = createTextInput(subtask);
        let editButton = createEditButton(textInput, index);
        let deleteButton = createDeleteButton(index);
        li.appendChild(checkbox);
        li.appendChild(textInput);
        li.appendChild(editButton);
        li.appendChild(deleteButton);
        subtaskList.appendChild(li);
    });
}

/**
 * Creates an error element for the category.
 * @returns {HTMLDivElement} The created error element.
 */
function createCategoryErrorElement() {
    let errorMsg = document.createElement("div");
    errorMsg.id = "categoryError";
    errorMsg.style.color = "red";
    return errorMsg;
}

/**
 * Hides the error message associated with category validation by setting its display style to none.
 */
function hideCategoryError() {
    let errorMsg = document.getElementById("categoryError");
    if (errorMsg) {
        errorMsg.style.display = "none";
    }
}

/**
 * Retrieves the values of all checked contact checkboxes in the form.
 * @returns {Array<string>} An array of values representing the selected contacts.
 */
function getAssignedContacts() {
    return [...document.querySelectorAll(".contact-checkbox:checked")].map(
        (input) => input.value
    );
}

/**
 * Generates a unique identifier for a task using a random alphanumeric string.
 * @returns {string} A unique task identifier in the format 'task-{random_string}'.
 */
function generateTaskId() {
    return "task-" + Math.random().toString(36).substr(2, 9);
}

/**
 * Adds a new task to the tasks array with detailed information about the task.
 * @param {string} id - Unique identifier for the task.
 * @param {string} title - Title of the task.
 * @param {string} description - Description of the task.
 * @param {string} taskDate - Date associated with the task.
 * @param {string} category - Category of the task.
 * @param {string} userLevel - Access level required to view the task.
 * @param {Array<string>} assignedContacts - List of contact IDs assigned to the task.
 */
function addTaskToTasks(
    id,
    title,
    description,
    taskDate,
    category,
    userLevel,
    assignedContacts
) {
    tasks.push({
        id,
        title,
        description,
        taskDate,
        category,
        priority,
        subtasks,
        userLevel,
        status: currentTaskStatus,
        assignedContacts,
    });
}

/**
 * Toggles the visibility of the dropdown list and the checked user initials display based on their current state.
 * It displays the dropdown or the checked user initials, also updating the initials when hiding the dropdown.
 */
function fillDropdownList() {
    let dropdown = document.getElementById("dropDownContacts");
    let checkedUserInitials = document.getElementById("checkedUserInitials");
    if (dropdown.style.display === "none" || dropdown.style.display === "") {
        dropdown.style.display = "block";
        checkedUserInitials.style.display = "none";
    } else {
        dropdown.style.display = "none";
        checkedUserInitials.style.display = "flex";
        loadCheckedUserInitials();
    }
}

/**
 * Resets the fields of the task form to default values, including clearing text inputs, unchecking checkboxes,
 * resetting subtasks list, setting default priority, and refreshing user initials display.
 */
function removeCurrentInputValues() {
    document.getElementById("titleInput").value = "";
    document.getElementById("descriptionInput").value = "";
    document.getElementById("taskDate").value = "";
    document.getElementById("category").value = "";
    document
        .querySelectorAll(".contact-checkbox:checked")
        .forEach((checkbox) => {
            checkbox.checked = false;
        });
    subtaskInput.value = "";
    subtasks = [];
    setPriority("Medium");
    loadCheckedUserInitials();
    updateSubtaskList();
}
